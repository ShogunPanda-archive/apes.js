<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>http/server.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Application.html">Application</a><ul class='methods'><li data-type='method'><a href="Application.html#cleanup">cleanup</a></li><li data-type='method'><a href="Application.html#execute">execute</a></li><li data-type='method'><a href="Application.html#loadConfiguration">loadConfiguration</a></li><li data-type='method'><a href="Application.html#prepare">prepare</a></li><li data-type='method'><a href="Application.html#run">run</a></li></ul></li><li><a href="HTTP.Server.html">Server</a><ul class='methods'><li data-type='method'><a href="HTTP.Server.html#addCORSHandling">addCORSHandling</a></li><li data-type='method'><a href="HTTP.Server.html#addErrorHandling">addErrorHandling</a></li><li data-type='method'><a href="HTTP.Server.html#addMiddlewares">addMiddlewares</a></li><li data-type='method'><a href="HTTP.Server.html#addRoutes">addRoutes</a></li><li data-type='method'><a href="HTTP.Server.html#errorHandler">errorHandler</a></li><li data-type='method'><a href="HTTP.Server.html#execute">execute</a></li><li data-type='method'><a href="HTTP.Server.html#loadConfiguration">loadConfiguration</a></li><li data-type='method'><a href="HTTP.Server.html#logRequest">logRequest</a></li><li data-type='method'><a href="HTTP.Server.html#prepare">prepare</a></li><li data-type='method'><a href="HTTP.Server.html#redirectTo">redirectTo</a></li><li data-type='method'><a href="HTTP.Server.html#sendGeneralError">sendGeneralError</a></li><li data-type='method'><a href="HTTP.Server.html#sendResponse">sendResponse</a></li><li data-type='method'><a href="HTTP.Server.html#setupStaticFolder">setupStaticFolder</a></li><li data-type='method'><a href="HTTP.Server.html#sslConfig">sslConfig</a></li></ul></li><li><a href="Logger.html">Logger</a><ul class='methods'><li data-type='method'><a href="Logger.html#debug">debug</a></li><li data-type='method'><a href="Logger.html#error">error</a></li><li data-type='method'><a href="Logger.html#fatal">fatal</a></li><li data-type='method'><a href="Logger.html#info">info</a></li><li data-type='method'><a href="Logger.html#prepare">prepare</a></li><li data-type='method'><a href="Logger.html#warn">warn</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="HTTP.html">HTTP</a><ul class='methods'><li data-type='method'><a href="HTTP.html#.Profiler">Profiler</a></li></ul></li><li><a href="Utils.html">Utils</a><ul class='methods'><li data-type='method'><a href="Utils.html#.decodeBase64">decodeBase64</a></li><li data-type='method'><a href="Utils.html#.elapsedTime">elapsedTime</a></li><li data-type='method'><a href="Utils.html#.encodeBase64">encodeBase64</a></li><li data-type='method'><a href="Utils.html#.md5">md5</a></li><li data-type='method'><a href="Utils.html#.parseBoolean">parseBoolean</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#default">default</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">http/server.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * This file is part of the apes.js npm package. Copyright (C) 2016 and above Shogun &lt;shogun@cowtech.it>.
 * Licensed under the MIT license, which can be found at http://www.opensource.org/licenses/mit-license.php.
 */
"use strict";
const path = require("path");
const fs = require("fs-extra");
const express = require("express");
const bodyParser = require("body-parser");
const compression = require("compression");
const http = require("http");
const https = require("https");
const application_1 = require("../application");
const logger_1 = require("../logger");
const utils_1 = require("../utils");
const profiler_1 = require("./profiler");
const VALID_JSON_BODY = /^application\/(.+\+)?json/;
const S_TO_MS = 1000;
const DEFAULT_CORS_MAX_AGE = 31536000; // One year
const HTTP_STATUS_OK = 200;
const HTTP_STATUS_NO_CONTENT = 204;
const HTTP_STATUS_BAD_REQUEST = 400;
const HTTP_STATUS_NOT_FOUND = 404;
const HTTP_STATUS_ERROR = 500;
/**
 * A HTTP server template class.
 *
 * @memberOf HTTP
 */
class Server extends application_1.default {
    /**
     * Prepares the HTTP server for execution.
     *
     * @returns {Promise&lt;winston.LoggerInstance | Logger | Error | void>}
     */
    prepare() {
        this.requestsLogger = new logger_1.default(`${application_1.default.processName}-requests`, !application_1.default.production);
        this.express = express();
        // Add base middlewares and configure Express
        this.express.use(profiler_1.default);
        // Add GZIP compression and parse JSON body
        if (application_1.default.production)
            this.express.use(compression({ threshold: 0 }));
        this.express.use(bodyParser.json({ type: (req) => VALID_JSON_BODY.test(req.header("Content-Type")) }));
        // Only accept JSON bodies
        this.express.use(bodyParser.text({ type: (req) => !(VALID_JSON_BODY.test(req.header("Content-Type"))) }));
        this.express.use((req, res, next) => {
            if (typeof req.body === "string" &amp;&amp; req.body.length)
                throw new SyntaxError(`Content-Type header must be match regular expression /${VALID_JSON_BODY.source}/ and the data must a valid encoded JSON.`);
            next();
        });
        // Configure express behavior
        this.express.set("json spaces", application_1.default.production ? 0 : 2);
        this.express.enable("trust proxy");
        // Diagnostic ping
        this.express.get("/ping", (req, res) => {
            res.status(HTTP_STATUS_OK).set({ "Content-Type": "text/plain", "X-Up-Time": `${process.uptime() * S_TO_MS}ms` }).end("pong");
        });
        // Add middlewares
        this.addMiddlewares();
        // Add routes
        this.addRoutes();
        // Add error handling
        this.addErrorHandling();
        // Setup logging
        return this.requestsLogger.prepare();
    }
    /**
     * Executes the HTTP server.
     *
     * @returns {Promise&lt;winston.LoggerInstance | Logger | Error | void>}
     */
    execute() {
        return new Promise((resolve, reject) => {
            const sockets = new Set();
            // Create a HTTP(s) server - SSL is forbiddne in production mode since there should always be a webserver like Nginx in front
            const useSSL = (process.env.SSL || this.configuration.httpServer.ssl.enabled) &amp;&amp; !application_1.default.production;
            this.server = useSSL ? https.createServer(this.sslConfig(), this.express) : http.createServer(this.express);
            // Listen to the port
            this.server.listen(this.configuration.httpServer.port, () => {
                this.logger.info(`Listening for HTTP${useSSL ? "S" : ""} on port ${this.configuration.httpServer.port}.`);
            });
            // Socket tracking to allow to force a shutdown - Otherwise server.close will wait for connection to end.
            this.server.on("connection", (socket) => {
                sockets.add(socket);
                socket.on("close", () => sockets.delete(socket));
            });
            this.server.on("error", reject);
            // Handle termination signals
            for (let signal of ["SIGTERM", "SIGINT", "SIGUSR2"]) {
                process.removeAllListeners(signal);
                process.on(signal, () => {
                    // Terminate all pending sockets
                    for (let socket of sockets)
                        socket.destroy();
                    // Terminate the server and exit
                    this.server.close((error) => {
                        return error ? reject(error) : resolve();
                    });
                });
            }
        });
    }
    /**
     * Loads and parses the configuration file.
     *
     * @returns {Promise&lt;any | Error>} The configuration in case of success, the error otherwise.
     */
    loadConfiguration() {
        return super.loadConfiguration().then(() => {
            if (!this.configuration.httpServer)
                this.configuration.httpServer = {};
            if (!this.configuration.httpServer.port)
                this.configuration.httpServer.port = Server.defaultPort;
            if (!this.configuration.httpServer.ssl)
                this.configuration.httpServer.ssl = { enabled: false };
            return Promise.resolve(this.configuration);
        });
    }
    /**
     * Adds middleware to the Express server. This is reserved for subclasses to override. Default implementation does nothing.
     */
    addMiddlewares() {
        // Default implementation is a no-op
    }
    /**
     * Adds routes to the Express server. This is reserved for subclasses to override. Default implementation does nothing.
     */
    addRoutes() {
        // TODO@PI: Write me
    }
    /**
     * Adds error handling to the Express server.
     */
    addErrorHandling() {
        // Default catch all and error handler
        this.express.use((req, res) => {
            this.sendGeneralError(req, res, HTTP_STATUS_NOT_FOUND, "Not Found.");
        });
        // Error handler for unhandled exceptions
        this.express.use(this.errorHandler.bind(this));
    }
    /**
     * Adds CORS handling to the Express server.
     *
     * @param {string} origin A value for the `Access-Control-Allow-Origin` header. If not provided, will be inferred by requests' `Origin` header.
     * @param {string} headers A value for `Access-Control-Allow-Headers` header. If not provided, `*` will be used.
     * @param {string} methods A value for `Access-Control-Allow-Methods` header. If not provided, only **GET** and **POST** methods will be allowed.
     * @param {string} maxAge A value for `Access-Control-Max-Age` header. If not provided, one **year** will be used.
     */
    addCORSHandling(origin, headers, methods, maxAge) {
        this.express.use((req, res, next) => {
            if (!origin)
                origin = req.header("Origin");
            if (origin) {
                res.set({
                    "Access-Control-Allow-Origin": req.header("Origin") || origin,
                    "Access-Control-Allow-Headers": headers || "*",
                    "Access-Control-Allow-Methods": methods || "GET, POST",
                    "Access-Control-Max-Age": (maxAge || DEFAULT_CORS_MAX_AGE).toString()
                });
            }
            next();
        });
        this.express.options("/:unused*?", (req, res) => {
            res.status(HTTP_STATUS_NO_CONTENT).end();
        });
    }
    /**
     * Configures Express static file serving.
     *
     * @param {string} dir The folder to use as root for static files.
     * @param {string} root The base folder to get a absolute path for `dir`.
     * @returns {string} The absolute static files folder.
     */
    setupStaticFolder(dir, root) {
        const final = path.resolve(root || application_1.default.root, dir);
        this.express.use(express.static(final));
        return final;
    }
    /**
     * Load SSL certificate and key for HTTPS servers.
     *
     * @returns {{key: Buffer, cert: Buffer}} The loaded certificates.
     */
    sslConfig() {
        return {
            key: fs.readFileSync(path.resolve(application_1.default.root, this.configuration.httpServer.ssl.key || "config/ssl/private-key.pem")),
            cert: fs.readFileSync(path.resolve(application_1.default.root, this.configuration.httpServer.ssl.certificate || "config/ssl/certificate.pem"))
        };
    }
    /**
     * Replies with a HTTP redirect response to the client.
     *
     * @param {express.Request} req The current Express request.
     * @param {express.Response} res The current Express response.
     * @param {number} code The HTTP redirect code to use. Defaults to `302`.
     * @param {string} destination The URL where redirect to.
     * @param {number[]} startTime The starting time of the request, as returned by `process.hrtime()`.
     */
    redirectTo(req, res, code, destination, startTime) {
        if (!startTime)
            startTime = req.startTime || process.hrtime();
        if (!code)
            code = 302;
        this.logRequest(code, req, startTime);
        res.redirect(code, destination);
    }
    /**
     * Sends a response back to the client.
     *
     * @param {express.Request} req The current Express request.
     * @param {express.Response} res The current Express response.
     * @param {number} code The HTTP response code to use. Defaults to `200`.
     * @param {any} content The data to send back. Strings will set type to be `text/plain`, otherwise `application/json` will be used.
     * @param {number[]} startTime The starting time of the request, as returned by `process.hrtime()`.
     */
    sendResponse(req, res, code, content, startTime) {
        if (!startTime)
            startTime = req.startTime || process.hrtime();
        if (!code)
            code = 200;
        this.logRequest(code, req, startTime);
        res.status(code);
        if (typeof content === "string")
            res.type("text");
        content !== null &amp;&amp; typeof content !== "undefined" ? res.send(content) : res.end();
    }
    /**
     * Sends a error response back to the client.
     *
     * @param {express.Request} req The current Express request.
     * @param {express.Response} res The current Express response.
     * @param {number} code The HTTP response code to use. Defaults to `200`.
     * @param {string} message The error message to send back.
     * @param {boolean} single If `true`, error will be wrapped in a `error` key, otherwise it will be wrapped in `errors` key.
     */
    sendGeneralError(req, res, code, message, single = false) {
        const body = { code, message };
        this.sendResponse(req, res, code, single ? { error: body } : { errors: [body] });
    }
    /**
     * The Express catch all error handler.
     *
     * @param {Error | string} error The occurred error.
     * @param {express.Request} req The current Express request.
     * @param {express.Response} res The current Express response.
     * @param {express.NextFunction} next The next middleware. This is to comply with Express API, but the middleware is never called.
     */
    errorHandler(error, req, res, next) {
        if (res.headersSent)
            return false;
        if (error instanceof SyntaxError &amp;&amp; req.method === "POST") {
            return res.status(HTTP_STATUS_BAD_REQUEST).json({
                errors: [{
                        code: HTTP_STATUS_BAD_REQUEST,
                        message: "Invalid JSON POST data received.",
                        error: error.message
                    }]
            });
        }
        // Log the error
        this.logger.error(error);
        // On production show a generic message
        if (application_1.default.production)
            return this.sendGeneralError(req, res, HTTP_STATUS_ERROR, "Internal Application Error.");
        // If it's a string, don't try to get type and stack
        if (typeof error === "string")
            return this.sendGeneralError(req, res, HTTP_STATUS_ERROR, error);
        // Format stack
        const stack = error.stack ? error.stack.split("\n") : [];
        stack.shift();
        this.sendResponse(req, res, HTTP_STATUS_ERROR, { type: error.name, message: error.message, stack: stack.map(s => s.trim().replace(/^at\s/, "")) });
    }
    /**
     * Logs a request using the requestsLogger.
     *
     * @param {number} code The HTTP code sent to the client.
     * @param {express.Request} req The current Express request.
     * @param {number[]} startTime The starting time of the request, as returned by `process.hrtime()`.
     * @returns {winston.LoggerInstance} The requestsLogger backend.
     */
    logRequest(code, req, startTime) {
        let method = null;
        switch (Math.floor(code / 100)) {
            case 4:
                method = "warn";
                break;
            case 5:
                method = "error";
                break;
            case 3:
                method = "debug";
                break;
            default:
                method = "info";
                break;
        }
        return Reflect.get(this.requestsLogger, method)(Object.assign({
            status: code,
            elapsed: utils_1.elapsedTime(startTime),
            ip: req.ip.replace(/^::ffff:/, ""),
            method: req.method,
            url: req.url
        }, req.method === "POST" ? { body: req.body } : {}, req.extraLogAttributes || {}));
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A HTTP server template class.
 *
 * @memberOf HTTP
 */
exports.default = Server;
/**
 * The default HTTP port.
 *
 * @type {number}
 */
Server.defaultPort = 3000;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.1</a> on Tue Sep 20 2016 09:16:32 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>

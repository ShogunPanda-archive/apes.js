<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/utils.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/ShogunPanda/apes" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/application.js~Application.html">Application</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/http-server.js~HTTPServer.html">HTTPServer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/logger.js~Logger.html">Logger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/runtime-error.js~RuntimeError.html">RuntimeError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/utils.js~Utils.html">Utils</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/utils.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * This file is part of the apes.js npm package. Copyright (C) 2016 and above Shogun &lt;shogun@cowtech.it&gt;.
 * Licensed under the MIT license, which can be found at http://www.opensource.org/licenses/mit-license.php.
 */

const moment = require(&quot;moment&quot;);
const crypto = require(&quot;crypto&quot;);

const Constants = require(&quot;./constants&quot;);

/**
 * A set of common utility methods.
 *
 * @class Utils
 */
class Utils{
  /**
   * Parses a date string in UTC timezone.
   *
   * @param {string} date The date to parse.
   * @returns {moment} The parsed date.
   * @member {Utils}
   */
  static utcDate(date){
    if(!date)
      date = moment().format(&quot;YYYY-MM-DD&quot;);

    return moment.utc(`${date} 00:00:00 +0000`, &quot;YYYY-MM-DD HH:mm:ss Z&quot;);
  }

  /**
   * Flattens an array.
   *
   * @param {array} array The array to flatten
   * @param {number} [maxDepth=-1] The maximum level to flatten.
   * @param {array} [result=[]] **For internal use.**
   * @returns {array} The flattened array.
   */
  static flatten(array, maxDepth = -1, result = []){
    if(!Array.isArray(array))
      array = [array];

    for(let item of array){ // eslint-disable-line prefer-const
      if(Array.isArray(item) &amp;&amp; maxDepth !== 0)
        Utils.flatten(item, maxDepth - 1, result);
      else
        result.push(item);
    }

    return result;
  }

  /**
   * Removes duplicate entries inside an array.
   *
   * @param {array} array The array to unicize.
   * @returns {array} The input array with all duplicate values removed.
   */
  static uniq(array){
    if(!Array.isArray(array))
      array = [array];

    return [...new Set(array)];
  }

  /**
   * Removes duplicate entries inside an array.
   *
   * @param {array} array The array to unicize.
   * @returns {array} The input array with all duplicate values removed.
   */
  static unique(array){
    return Utils.uniq(array);
  }

  /**
   * Checks whether a string is empty.
   *
   * @param {string} target The string to verify.
   * @returns {boolean} `true` if `target` is a non-string or if it is empty, `false` otherwise.
   */
  static isEmptyString(target){
    return typeof target !== &quot;string&quot; || !target.trim().length;
  }

  /**
   * Tokenizes a list of string using a separator.
   *
   * @param {string[]} list The list of strings to tokenize.
   * @param {string|Regex} [pattern=/\s*,\s*\/] The pattern to use as separator.
   * @returns {array} The list of tokens.
   */
  static tokenize(list, pattern = /\s*,\s*/){
    if(!Array.isArray(list))
      list = [list];

    const entries = Utils.flatten(list).filter(k =&gt; k).map(el =&gt; el.toString().split(pattern).map(k =&gt; k.trim())); // Flatten, remove empty values, split by comma and trim
    return Utils.uniq(Utils.flatten(entries).filter(k =&gt; k)); // Flatten again, remove empty values, then duplicates
  }

  /**
   * Encodes a string to Base 64 encoding.
   *
   * @param {string} data The data to encode.
   * @returns {string} The enccoded data.
   */
  static encodeBase64(data){
    return Buffer.from(data, &quot;utf8&quot;).toString(&quot;base64&quot;).toString(&quot;base64&quot;);
  }

  /**
   * Decodes a string from Base 64 encoding.
   *
   * @param {string} data The data to decode.
   * @param {boolean} [asString=true] If `true`, a UTF-8 string will be returned, otherwise a Node.js Buffer.
   * @returns {string|Buffer} The decoded data.
   */
  static decodeBase64(data, asString = true){
    const decoded = Buffer.from(data, &quot;base64&quot;);

    return asString ? decoded.toString(&quot;utf8&quot;) : decoded;
  }

  /**
   * Computes the MD5 hash of a string.
   *
   * @param {string} data The string to compute the hash of.
   * @returns {string} The MD5 hash of the input string.
   */
  static md5(data){
    return crypto.createHash(&quot;md5&quot;).update(data).digest(&quot;hex&quot;);
  }

  /**
   * Parses a object as a boolean.
   *
   * @param {any} value The value to parse.
   * @returns {boolean} The boolean value.
   */
  static parseBoolean(value){
    return value &amp;&amp; value.toString().match(Constants.Utils.TRUE_BOOLEAN_MATCHER) !== null;
  }

  /**
   * Parses a date.
   *
   * @param {string|number} raw The string or number to parse. Numbers are interpreted as `X days ago`, positive and negative values have the same meaning.
   * @param {moment|number} [fallback=null] The fallback value to return when parsing fails.
   * @returns {moment} The parsed date.
   */
  static parseDate(raw, fallback = null){
    if(typeof raw === &quot;string&quot; || typeof raw === &quot;number&quot;){
      raw = raw.toString();

      let value = null;

      if(raw.match(/^(-?)\d+$/)) // Relative days ago. Future is obviously not supported. Positive and negative values have the same meaning
        value = Utils.utcDate().subtract(Math.abs(parseInt(raw, 0)), &quot;d&quot;);
      else if(raw.match(/^\d{4}-\d{2}-\d{2}$/)) // Absolute date in the format YYYY-MM-DD.
        value = Utils.utcDate(raw);

      if(value &amp;&amp; value.isValid())
        return value;
    }

    if(typeof fallback === &quot;number&quot;)
      return Utils.utcDate().subtract(Math.abs(fallback), &quot;d&quot;);

    return fallback;
  }

  /**
   * Parses a timestamp.
   *
   * @param {string} raw The string to parse.
   * @param {string} [formats=[&quot;YYYY-MM-DDTHH:mm:ssZ&quot;, &quot;YYYY-MM-DDTHH:mm:ss.SSSZZ&quot;]] A list of format to use for parsing.
   * @param {boolean} [utc=true] Whether to return the timestamp in UTC timezone.
   * @param {any} [fallback=null] The fallback value to return when parsing fails.
   * @returns {moment} The parsed timestamp.
   */
  static parseDateTime(raw, formats = [&quot;YYYY-MM-DDTHH:mm:ssZ&quot;, &quot;YYYY-MM-DDTHH:mm:ss.SSSZZ&quot;], utc = true, fallback = null){
    for(let format of formats){ // eslint-disable-line prefer-const
      const value = moment(raw, format);

      if(value.isValid())
        return utc ? value.utc() : value;
    }

    if(typeof fallback === &quot;number&quot;)
      return Utils.utcDate().subtract(Math.abs(fallback), &quot;d&quot;);

    return fallback;
  }

  /**
   * Serializes a timestamp as a string.
   *
   * @param {moment} date The timestamp to serialize.
   * @param {string} [format=&quot;YYYY-MM-DDTHH:mm:ssZ&quot;] The format to use.
   * @returns {string} The serialized timestamp.
   */
  static serializeDate(date, format = &quot;YYYY-MM-DDTHH:mm:ssZ&quot;){
    return date.utc().format(format);
  }

  /**
   * Returns the elapsed time (in milliseconds) since a reference time.
   *
   * @param {number[]} start The starting reference time, as returned by `process.hrtime()`.
   * @param {boolean} [round=true] Whether or not round the results.
   * @param {number} [precision=Constants.Utils.OUTPUT_PRECISION] The precision to run in case of rounding.
   * @returns {number|string} If `round` is true, a string with the elapsed time, otherwise a full precision number.
   */
  static elapsedTime(start, round = true, precision = Constants.Utils.OUTPUT_PRECISION){
    if(!start)
      return null;

    let elapsed = process.hrtime(start);
    elapsed = elapsed[0] * Constants.Utils.S_TO_MS + elapsed[1] / Constants.Utils.US_TO_MS;

    if(round)
      elapsed = elapsed.toPrecision(precision);

    return elapsed;
  }

  /**
   * Returns a random value.
   *
   * @param {number} min The minimum acceptable value.
   * @param {number} max The maximum acceptable value.
   * @returns {number} A random number between `min` and `max` (inclusive).
   */
  static random(min, max){
    return min + Math.random() * (max - min);
  }

  /**
   * Returns a sequence of numbers.
   *
   * @param {any} start The starting number.
   * @param {any} end The ending number.
   * @param {boolean} [inclusive=false] Whether or not `end` is included in the returned array.
   * @returns {number[]} A sequence of numbers starting with `start` and ending with `end`.
   */
  static range(start, end, inclusive = false){
    // Parse as numbers
    start = parseFloat(start, 0);
    end = parseFloat(end, 0);

    // Early returns in case of invalids and negatives
    if(isNaN(start) || isNaN(end) || start &lt; 0 || end &lt; 0)
      return [];
    else if(start &gt; end) // Swap badly ordered arguments
      [end, start] = [start, end];

    // Make integers
    start = Math.floor(start);
    end = Math.floor(end);

    // Generate the range
    const length = end - start + (inclusive ? 1 : 0);
    return [...Array(length)].map((_, i) =&gt; start + i);
  }

  /**
   * Creates a async function which resolves after the specified amount.
   *
   * @param {any} amount The amount of time to wait before returning, in milliseconds.
   */
  static async delay(amount){
    await new Promise(resolve =&gt; setTimeout(resolve, amount));
  }
}

module.exports = Utils;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
